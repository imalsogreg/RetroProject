/*
*******************************************************************
PROGRAM:
    parmextract

DESCRIPTION:
    scans ascii/binary parameter files generated by the spikeparms program and
    extracts/analyzes the parameters associated with the specified
    indices

AUTHOR:
    Written by Matthew Wilson
    Massachusetts Institute of Technology
    Cambridge MA 02139
    wilson@ai.mit.edu

DATES:
    original program 5/91
    program update 8/96
*******************************************************************
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* MWL headers */
#include <header.h>
#include <iolib.h>


#define VERSION "1.21"

#define MAX_VECTORS 500000
#define NPARMS 100

#define SHOWMINMAX	0
#define SHOWBOX		1
#define SHOWALLBOXES	2

#define ASCII 		0
#define BINARY		1
#define OLDBINARY		100
typedef struct result_type {
    int	inputformat;
    int	fieldcount;
    FILE	*fpin;
} Result;


typedef struct index_type {
    int		*index;
    int		n;
    int		all;
} Index;

char	*fname;
int	convert;
int	verbose;

int intcompare(i1,i2)
int	*i1,*i2;
{
    return(*i1 - *i2);
}

void ReadIndices(fp,idx)
FILE	*fp;
Index	*idx;
{
int	count;
char	line[1000];
int	ival;

    count = 0;
    while(!feof(fp)){
	if(fgets(line,1000,fp) == NULL) break;
	if(line[0] == '%') continue;
	if(sscanf(line,"%d",&ival) == 1){
	    idx->index[count++] = ival;
	}
	if(count >= MAX_VECTORS){
	    fprintf(stderr,"exceeded maximum number of spikes (%d)\n", 
	    MAX_VECTORS);
	    break;
	}
    }
    idx->n = count;
}


void ComputeBounds(fp,idx,fpout,noid,showmode,parm1,parm2,clusterid)
FILE	*fp;
Index	*idx;
FILE	*fpout;
int	noid;
int	showmode;
int	parm1,parm2;
int	clusterid;
{
int	i,j;
double	v[NPARMS];
double	maxval[NPARMS];
double	minval[NPARMS];
char	line[1000];
int	current;
int	nparms = 0;
int	ival;
    /*
    ** read in the first valid line
    */
    while(!feof(fp)){
	if(fgets(line,1000,fp) == NULL) break;
	if(line[0] == '%') continue;
	break;
    }
    if(noid){
	current = 0;
    } else {
	if(sscanf(line,"%d",&current) != 1){
	    fprintf(stderr,"unable to read index from parameter file line:\n");
	    fprintf(stderr,"\t%s\n",line);
	    exit(0);
	}
    }
    for(i=0;i<idx->n;i++){
	/*
	** scan up to the line corresponding to the index value
	*/
	while(current != idx->index[i]){
	    while(!feof(fp)){
		if(fgets(line,1000,fp) == NULL){
		    fprintf(stderr,
		    "unable to read index %d from parameter file\n",
		    idx->index[i]);
		    exit(0);
		}
		if(line[0] == '%') continue;
		break;
	    }
	    if(noid){
		current++;
	    } else {
		if(sscanf(line,"%d",&ival) == 1){
		    current = ival;
		}
	    }
	}
	/*
	** read in the parameter values
	*/
	nparms = sgetargs(line,NPARMS,v);

	/*
	** keep track of max/min values for cluster bounds
	*/
	if(i == 0){
	    /*
	    ** initialize max/min
	    */
	    for(j=0;j<nparms;j++){
		maxval[j] = v[j];
		minval[j] = v[j];
	    }
	} else
	for(j=0;j<nparms;j++){
	    if(v[j] > maxval[j]) maxval[j] = v[j];
	    if(v[j] < minval[j]) minval[j] = v[j];
	}
    }
    /*
    ** write out the results
    */
    switch(showmode){
    case SHOWBOX:
	if(parm1 >= nparms){
	    fprintf(stderr,"invalid parameter index '%d'\n",parm1);
	    return;
	}
	if(parm2 >= nparms){
	    fprintf(stderr,"invalid parameter index '%d'\n",parm2);
	    return;
	}
	/*
	** output the clusterid and projection information
	*/
	fprintf(fpout,"%% Clusterid:\n");
	fprintf(fpout,"%d\n",clusterid);
	fprintf(fpout,"%% Projections:\n");
	fprintf(fpout,"%d\t%d\n",parm1,parm2);
	fprintf(fpout,"%s%d\n%s%d\n","P",parm1,"P",parm2);
	/*
	** output the number of coordinates 
	*/
	fprintf(fpout,"%% Bounds coordinates:\n");
	fprintf(fpout,"4\n");
	/*
	** output coordinates for each corner of the bounding box
	*/
	fprintf(fpout,"%g\t%g\n",minval[parm1],minval[parm2]);
	fprintf(fpout,"%g\t%g\n",minval[parm1],maxval[parm2]);
	fprintf(fpout,"%g\t%g\n",maxval[parm1],maxval[parm2]);
	fprintf(fpout,"%g\t%g\n",maxval[parm1],minval[parm2]);
	break;
    case SHOWALLBOXES:
	if(parm1 >= nparms){
	    fprintf(stderr,"invalid parameter index '%d'\n",parm1);
	    return;
	}
	if(parm2 >= nparms){
	    fprintf(stderr,"invalid parameter index '%d'\n",parm2);
	    return;
	}
	for(i=parm1;i<=parm2;i++){
	    for(j=i;j<=parm2;j++){
		if(i == j) continue;
		/*
		** output the clusterid and projection information
		*/
		fprintf(fpout,"%% Clusterid:\n");
		fprintf(fpout,"%d\n",clusterid);
		fprintf(fpout,"%% Projections:\n");
		fprintf(fpout,"%d\t%d\n",i,j);
		fprintf(fpout,"%s%d\n%s%d\n","P",i,"P",j);
		/*
		** output the number of coordinates 
		*/
		fprintf(fpout,"%% Bounds coordinates:\n");
		fprintf(fpout,"4\n");
		/*
		** output coordinates for each corner of the bounding box
		*/
		fprintf(fpout,"%g\t%g\n",minval[i],minval[j]);
		fprintf(fpout,"%g\t%g\n",minval[i],maxval[j]);
		fprintf(fpout,"%g\t%g\n",maxval[i],maxval[j]);
		fprintf(fpout,"%g\t%g\n",maxval[i],minval[j]);
	    }
	}
	break;
    case SHOWMINMAX:
	fprintf(fpout,"%%%%CLUSTER %s\n",fname);
	fprintf(fpout,"%%%%NPARMS %d\n",nparms);
	for(j=0;j<nparms;j++){
	    fprintf(fpout,"%g\t%g\n",minval[j],maxval[j]);
	}
	break;
    }
}

void DisplayParms(result,idx,fpout,noid)
Result	*result;
Index	*idx;
FILE	*fpout;
int	noid;
{
int	i;
char	line[1000];
int	current;
FILE	*fp;

    fp = result->fpin;
    /*
    ** read in the first valid line
    */
    while(!feof(fp)){
	if(fgets(line,1000,fp) == NULL) break;
	if(line[0] == '%') continue;
	break;
    }
    if(noid){
	current = 0;
    } else {
	if(sscanf(line,"%d",&current) != 1){
	    fprintf(stderr,"unable to read index from parameter file, line:\n");
	    fprintf(stderr,"\t%s\n",line);
	    exit(0);
	}
    }
    for(i=0;i<idx->n;i++){
	/*
	** scan up to the line corresponding to the index value
	*/
	while(current != idx->index[i]){
	    while(!feof(fp)){
		if(fgets(line,1000,fp) == NULL){
		    fprintf(stderr,
		    "unable to read index %d from parameter file\n",
		    idx->index[i]);
		    exit(0);
		}
		if(line[0] == '%') continue;
		break;
	    }
	    if(noid){
		current++;
	    } else {
		/*
		** the line should be preparsed to cut out the remaining
		** arguments which appear to be parsed by sscanf
		** regardless of the control string.
		** Also an error in the format of any number in the
		** line will crash sscanf.
		*/
		sscanf(line,"%d",&current);
	    }
	}
	fprintf(fpout,"%s",line);
    }
}

void DisplayBinaryParms(result,idx,fpout,noid,headersize,outputformat)
Result	*result;
Index	*idx;
FILE	*fpout;
int	noid;
int	headersize; /* unused */
int	outputformat;
{
int	i,j;
int	current;
int	*ReadBinaryFormatInfo();
int	*vectorformat;
int	vectorsize;
float	vector[NPARMS];
FILE	*fp;

    fp = result->fpin;

    if(result->inputformat == OLDBINARY){
	/*
	** read in the vectory format header
	*/
	if((vectorformat = ReadBinaryFormatInfo(fp,&vectorsize)) == NULL){
	    return;
	}
    } else 
    if(result->inputformat == BINARY){
	vectorsize = result->fieldcount;
    } else {
	return;
    }
    if(verbose)
	fprintf(stderr,"vectorsize = %d\n",vectorsize);
    if(idx->all == 1){
	/*
	** read all of the vectors
	*/
	while(!feof(fp)){
	    if(fread(vector,sizeof(float),vectorsize,fp) != vectorsize){
		break;
	    }
	    if(convert){
		for(j=0;j<vectorsize;j++){
		    ConvertData(vector+j,sizeof(float));
		}
	    }
	    if(outputformat == ASCII){
		for(j=0;j<vectorsize;j++){
		    fprintf(fpout,"%.16g\t",vector[j]);
		}
		fprintf(fpout,"\n");
	    } else {
		if(fwrite(vector,sizeof(float),vectorsize,fpout) != vectorsize){
		    fprintf(stderr,
		    "ERROR: unable to write binary output vector\n");
		    return;
		}
	    }
	}
    } else {
	/*
	** read in the first binary data vector
	*/
	if(fread(vector,sizeof(float),vectorsize,fp) != vectorsize){
	    return;
	}
	if(convert){
	    for(j=0;j<vectorsize;j++){
		ConvertData(vector+j,sizeof(float));
	    }
	}
	if(noid){
	    current = 0;
	} else {
	    current = vector[0];
	}
	if(verbose)
	    fprintf(stderr,"nindices = %d\n",idx->n);
	for(i=0;i<idx->n;i++){
	    /*
	    ** read in the data vector which has an id matching the current index
	    */
	    while(current != idx->index[i]){
		if(fread(vector,sizeof(float),vectorsize,fp) != vectorsize){
		    fprintf(stderr,
		    "ERROR: unable to read index %d from parameter file\n",
		    idx->index[i]);
		    return;
		}
		if(convert){
		    for(j=0;j<vectorsize;j++){
			ConvertData(vector+j,sizeof(float));
		    }
		}
		if(noid){
		    current++;
		} else {
		    current = vector[0];
		}
	    }
	    if(outputformat == ASCII){
		for(j=0;j<vectorsize;j++){
		    fprintf(fpout,"%.16g\t",vector[j]);
		}
		fprintf(fpout,"\n");
	    } else {
		if(fwrite(vector,sizeof(float),vectorsize,fpout) != vectorsize){
		    fprintf(stderr,
		    "ERROR: unable to write binary output vector\n");
		    return;
		}
	    }
	}
    }
}

int main(argc,argv)
int argc;
char **argv;
{
Index	index;
char	*parmstring;
int	nxtarg;
FILE	*fpindex;
FILE	*fpout;
int	compute_bounds;
int	display_parms;
int	noid;
int	parm1 = 0;
int	parm2 = 0;
int	clusterid;
int	showmode;
int	headersize;
char	**header;
int	outputformat;
char	*parmfname = NULL;
int	allindices;
FieldInfo	fieldinfo;
Result	result;
int	i;
char	pname[100];
FILE	*fptmp;
int	pheadersize;
char	**pheader;
char	*ststr;
char	*etstr = NULL;
char	*sptr;

    convert = 0;
    nxtarg = 0;
    verbose = 0;
    index.n = 0;
    index.all = 0;
    index.index = (int *)malloc(MAX_VECTORS*sizeof(int));
    fpout = stdout;
    result.fpin = stdin;
    fpindex = NULL;
    fname = NULL;
    compute_bounds = 0;
    display_parms = 0;
    clusterid = 1;
    noid = 0;
    showmode = SHOWMINMAX;
    result.inputformat = ASCII;
    outputformat = ASCII;
    allindices = 0;

    while(++nxtarg < argc){
	if(strcmp(argv[nxtarg],"-usage") == 0){
	    fprintf(stderr,
	    "usage: %s [parmfile][-bounds][-show][-i index][-if indexfile][-iall]\n",
	    argv[0]);
	    fprintf(stderr,
	    "\t[-showbox parm1 parm2][-cluster id][-o file][-v][-noid]\n");
	    fprintf(stderr,"\t[-showallboxes parm1 parm2]\n");
	    fprintf(stderr,"\t[-binaryin][-asciiin][-binaryout][-asciiout]\n");
	    exit(0);
	} else
	if(strcmp(argv[nxtarg],"-version") == 0){
	    fprintf(stderr,"%s : version %s : updated %s\n",
		argv[0],VERSION,DATE);

/* passed in from makefile when building an RPM*/
#ifdef MWSOFT_RPM_STRING 
	    fprintf(stderr,"From RPM: %s\n",
		    MWSOFT_RPM_STRING);
#endif

	    fprintf(stderr,"%s\n",COPYRIGHT);

	    exit(0);
	} else
	if(strcmp(argv[nxtarg],"-asciiout") == 0){
	    outputformat = ASCII;
	} else
	if(strcmp(argv[nxtarg],"-asciiin") == 0){
	    result.inputformat = ASCII;
	} else
	if(strcmp(argv[nxtarg],"-binaryout") == 0){
	    outputformat = BINARY;
	} else
	if(strcmp(argv[nxtarg],"-binaryin") == 0){
	    result.inputformat = BINARY;
	} else
	if(strcmp(argv[nxtarg],"-cluster") == 0){
	    clusterid = atoi(argv[++nxtarg]);
	} else
	if(strcmp(argv[nxtarg],"-showbox") == 0){
	    compute_bounds = 1;
	    showmode = SHOWBOX;
	    parm1 = atoi(argv[++nxtarg]);
	    parm2 = atoi(argv[++nxtarg]);
	} else
	if(strcmp(argv[nxtarg],"-showallboxes") == 0){
	    compute_bounds = 1;
	    showmode = SHOWALLBOXES;
	    parm1 = atoi(argv[++nxtarg]);
	    parm2 = atoi(argv[++nxtarg]);
	} else
	if(strcmp(argv[nxtarg],"-v") == 0){
	    verbose = 1;
	} else
	if(strcmp(argv[nxtarg],"-bounds") == 0){
	    compute_bounds = 1;
	} else
	if(strcmp(argv[nxtarg],"-noid") == 0){
	    noid = 1;
	} else
	if(strcmp(argv[nxtarg],"-show") == 0){
	    display_parms = 1;
	} else
	if(strcmp(argv[nxtarg],"-i") == 0){
	    index.index[index.n++] = atoi(argv[++nxtarg]);
	} else
	if(strcmp(argv[nxtarg],"-if") == 0){
	    fname = argv[++nxtarg];
	    if((fpindex = fopen(fname,"r")) == NULL){
		fprintf(stderr,"unable to open index file '%s'\n",
		fname);
		exit(0);
	    }
	} else
	if(strcmp(argv[nxtarg],"-iall") == 0){
	    allindices = 1;
	} else
	if(strcmp(argv[nxtarg],"-o") == 0){
	    if((fpout = fopen(argv[++nxtarg],"w")) == NULL){
		fprintf(stderr,"unable to open output file '%s'\n",
		argv[nxtarg]);
		exit(0);
	    }
	} else
	if(argv[nxtarg][0] != '-'){
	    parmfname = argv[nxtarg];
	    if((result.fpin = fopen(parmfname,"r")) == NULL){
		fprintf(stderr,"unable to open parameter file '%s'\n",
		argv[nxtarg]);
		exit(0);
	    }
	} 
    }
    if(result.fpin == NULL){
	fprintf(stderr,"Must provide a parameter file\n");
	exit(0);
    }
    if(allindices){
	index.all = 1;
	if(verbose){
	    fprintf(stderr,"Processing all indices\n");
	}
    } else 
    if(index.n == 0){
	if(fpindex == NULL){
	    fprintf(stderr,"ERROR: must specify an index option\n");
	    exit(-1);
	}
	ReadIndices(fpindex,&index);
	/*
	** sort the indices
	*/
	qsort(index.index,index.n,sizeof(int),intcompare);
	if(verbose){
	    fprintf(stderr,"Processing %d indices\n",index.n);
	}
    } 
    /*
    ** read in the file header for the parameter file
    */
    parmstring = NULL;
    if((header = ReadHeader(result.fpin,&headersize)) != NULL){
	/*
	** compare architectures
	*/
	if((GetLocalArchitecture() == GetFileArchitecture(header)) ||
	    (GetFileArchitecture(header) == ARCH_UNKNOWN)) {
	    convert = 0;
	    if(verbose)
		fprintf(stderr,"No data conversion file from %s architecture.\n",
	    GetFileArchitectureStr(header));
	} else {
	    convert = 1;
	    fprintf(stderr,"Converting data from %s to %s architectures.\n",
		 GetFileArchitectureStr(header),
		 GetLocalArchitectureStr());
	}
	/*
	** try to determine the file format from the header
	*/
	result.inputformat = GetFileType(header);
	parmstring = GetFieldString(header);
    }
    /*
    ** Get the start and end time strings
    */
    if((ststr = GetHeaderParameter(header,"Start time:")) == NULL){
	/*
	** HACK ALERT
	*/
	/*
	** if absent the try to find it in another file
	*/
	/*
	** get the cluster number from the index file
	*/
	if(fname){
	    /*
	    ** go to the end and scan back until reaching a -
	    */
	    sptr = fname+strlen(fname);
	    while(sptr != fname && *sptr != '-') sptr--;
	    sprintf(pname,"p%s",sptr+1);
	    if((fptmp = fopen(pname,"r")) == NULL){
		fprintf(stderr,"could not find altername start time file %s\n",
		pname);
	    } else {
		/*
		** get the start time from the header
		*/
		if((pheader = ReadHeader(fptmp,&pheadersize)) != NULL){
		    if((ststr = GetHeaderParameter(pheader,"Start time:")) == NULL){
			fprintf(stderr,"could not find start time in header from %s\n", pname);
		    }
		    if((etstr = GetHeaderParameter(pheader,"End time:")) == NULL){
			fprintf(stderr,"could not find end time in header from %s\n", pname);
		    }
		}
		fclose(fptmp);
	    }
	}
    }

    BeginStandardHeader(fpout,argc,argv,VERSION);
    fprintf(fpout,"%% Parm file:\t%s\n",parmfname);
    fprintf(fpout,"%% Index file:\t%s\n",fname);
    fprintf(fpout,"%% Start Time:\t%s\n",ststr);
    fprintf(fpout,"%% End Time:\t%s\n",etstr);
    if(outputformat == BINARY){
	fprintf(fpout,"%% File type:\t%s\n","Binary");
    } else {
	fprintf(fpout,"%% File type:\t%s\n","Ascii");
    }
    if(parmstring){
	fprintf(fpout,"%% Fields:\t%s\n",parmstring);
    }
    result.fieldcount = GetFieldCount(parmstring);
    for(i=0;i<result.fieldcount;i++){
	GetFieldInfoByNumber(parmstring,i,&fieldinfo);
	/*
	** echo the field name
	fprintf(stderr,"P%d : '%s'\t%d\t%d\t%d\n",i,
	fieldinfo.name,
	fieldinfo.type,
	fieldinfo.size,
	fieldinfo.count
	);
	*/
    }
    /*
    ** deal with old and new binary formats
    */
    if(result.inputformat == BINARY){
	/*
	** is this an old binary format file?
	*/
	if(fieldinfo.type == -1){
	    result.inputformat = OLDBINARY;
	    if(verbose){
		fprintf(stderr,"OLDBINARY format\n");
	    }
	} else {
	    if(verbose){
		fprintf(stderr,"BINARY format\n");
	    }
	}
    }
    EndStandardHeader(fpout);
    if(compute_bounds){
	ComputeBounds(result.fpin,&index,fpout,noid,showmode,parm1,parm2,clusterid);
    }
    if(display_parms){
	if(verbose){
	    if(outputformat == BINARY){
		fprintf(stderr,"Binary output format\n");
	    } else {
		fprintf(stderr,"Ascii output format\n");
	    }
	}
	if(result.inputformat == BINARY || result.inputformat == OLDBINARY){
	    DisplayBinaryParms(&result,&index,fpout,noid,headersize,outputformat);
	} else {
	    DisplayParms(&result,&index,fpout,noid);
	}
    }
    exit(0);
}
